<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Autoritratto 2D</title>
  <style>
    html, body{
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background:#1f1f1f;
      overflow: hidden;
    }
    body{
      display:flex;
      align-items:center;
      justify-content:center;
    }
    canvas{ display:block; }

    /* ⭐ cursore stella anche DENTRO iframe */
html, body, *{
  cursor: url("../cursor/Red_star.png") 16 16, auto !important;
}
  </style>
</head>

<body>
<script src="https://cdn.jsdelivr.net/npm/p5@1.11.11/lib/p5.min.js"></script>
<script>
let img;
let dots = [];

// ---------- DETTAGLIO / SPAZIATURA ----------
const RESIZE_DIV = 6.0;
const SAMPLE = 2;
const SPACING = 9;

// ---------- ASPETTO DEI PUNTI ----------
const MIN_DOT = 0.8;
const MAX_DOT = 6.5;
const GAMMA = 0.60;
const IMAGE_EDGE_FADE = 55;

// ---------- MOVIMENTO ----------
const SPRING = 0.035;
const DAMPING = 0.86;
const MAG_RADIUS = 220;

// ✅ magnete: “giusto” (più forte della versione soft, ma controllato)
const MAG_FORCE  = 1.85;   // (era 1.25 soft, originale 2.7)
const FLOW       = 0.30;   // (era 0.22 soft, originale 0.45)
const MAG_CAP    = 0.42;   // cap più alto: torna più presenza senza strappo

function preload(){ img = loadImage("gr.png"); }

function setup(){
  makeResponsiveCanvas();
  pixelDensity(1);

  img.resize(floor(img.width / RESIZE_DIV), 0);
  img.loadPixels();

  buildDots();
}

function windowResized(){
  makeResponsiveCanvas();
  buildDots();
}

function makeResponsiveCanvas(){
  const s = min(windowWidth, windowHeight);
  createCanvas(s, s);
}

function buildDots(){
  dots = [];
  const w = img.width, h = img.height;

  const cols = floor((w - 1) / SAMPLE) + 1;
  const rows = floor((h - 1) / SAMPLE) + 1;

  const renderW = (cols - 1) * SPACING;
  const renderH = (rows - 1) * SPACING;

  const margin = 0.92;
  const s = min((width * margin) / renderW, (height * margin) / renderH);

  const cx = width / 2;
  const cy = height / 2;

  let jj = 0;
  for (let y = 0; y < h; y += SAMPLE){
    let ii = 0;
    for (let x = 0; x < w; x += SAMPLE){
      const idx = 4 * (y * w + x);
      const a = img.pixels[idx + 3];
      if (a < 5) { ii++; continue; }

      const r = img.pixels[idx];
      const g = img.pixels[idx + 1];
      const b = img.pixels[idx + 2];

      const gray = 0.2126*r + 0.7152*g + 0.0722*b;
      const g01 = pow(constrain(gray / 255, 0, 1), GAMMA) * 1.85;
      const d0 = lerp(MIN_DOT, MAX_DOT, g01);

      const localX = (ii * SPACING - renderW / 2) * s;
      const localY = (jj * SPACING - renderH / 2) * s;

      const hx = cx + localX;
      const hy = cy + localY;

      const edgeDist = min(x, w - 1 - x, y, h - 1 - y);
      const edgeFade = constrain(map(edgeDist, 0, IMAGE_EDGE_FADE, 0, 1), 0, 1);

      dots.push({
        hx, hy,
        x: hx, y: hy,
        vx: 0, vy: 0,
        gray,
        d0: d0 * s,
        edgeFade
      });

      ii++;
    }
    jj++;
  }
}

function draw(){
  background(0);
  noStroke();

  const mx = mouseX, my = mouseY;
  const mouseInside = (mx >= 0 && mx <= width && my >= 0 && my <= height);

  for (const p of dots){
    let ax = (p.hx - p.x) * SPRING;
    let ay = (p.hy - p.y) * SPRING;

    if (mouseInside){
      const dx = mx - p.x, dy = my - p.y;
      const r2 = dx*dx + dy*dy;

      if (r2 < MAG_RADIUS*MAG_RADIUS){
        const dist = sqrt(r2) + 1e-6;

        // falloff morbido
        let t = 1 - dist / MAG_RADIUS;
        t = t * t * (3 - 2 * t);

        const nx = dx / dist, ny = dy / dist;

        // componente magnete + swirl
        let mxAx = nx * MAG_FORCE * t;
        let mxAy = ny * MAG_FORCE * t;

        mxAx += -ny * FLOW * t;
        mxAy +=  nx * FLOW * t;

        // cap massimo per evitare “strappo”
        const m = sqrt(mxAx*mxAx + mxAy*mxAy);
        if (m > MAG_CAP){
          const k = MAG_CAP / m;
          mxAx *= k;
          mxAy *= k;
        }

        ax += mxAx;
        ay += mxAy;
      }
    }

    p.vx = (p.vx + ax) * DAMPING;
    p.vy = (p.vy + ay) * DAMPING;
    p.x += p.vx;
    p.y += p.vy;

    const speed = sqrt(p.vx*p.vx + p.vy*p.vy);
    const d = p.d0 + speed * 0.22;

    fill(p.gray, 255 * p.edgeFade);
    circle(p.x, p.y, d);
  }
}
</script>
</body>
</html>
